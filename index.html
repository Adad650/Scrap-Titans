<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Scrap Titans — Field Crates</title>
<style>
  :root{--bg:#0b0f14;--ink:#e5f3ff;--muted:#9ec0d8;--accent:#67d4ff;--ok:#55efc4;--warn:#ffd166;--danger:#ff6b6b}
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;overflow:hidden}
  #wrap{position:relative;width:100vw;height:100vh;display:grid;place-items:center}
  #game{width:100vw;height:100vh;display:block;background:#071019}
  .hud{position:absolute;left:50%;top:12px;transform:translateX(-50%);display:flex;gap:10px;align-items:center;
       background:rgba(15,23,34,.88);border:1px solid #1e324a;border-radius:14px;padding:8px 12px;backdrop-filter:blur(3px);z-index:5}
  .chip{font-size:12px;color:#cde9ff;background:#0e1c2c;border:1px solid #21344d;border-radius:999px;padding:2px 8px}
  .sep{width:1px;height:18px;background:#1e324a;opacity:.8}
  .score{font-weight:700;color:#86e7ff}
  .bar{width:160px;height:8px;background:#0a1624;border:1px solid #142236;border-radius:6px;overflow:hidden}
  .bar>i{display:block;height:100%;background:linear-gradient(90deg,var(--ok),#83f2ff)}
  .help{position:absolute;left:50%;bottom:12px;transform:translateX(-50%);color:#beddff;font-size:12px;background:rgba(11,19,31,.75);
        border:1px solid #1a2d43;border-radius:10px;padding:6px 10px;display:flex;gap:8px;align-items:center;z-index:5}
  .kbd{font-family:ui-monospace,Menlo,Consolas,monospace;background:#0e1a27;border:1px solid #1b3048;border-bottom-width:2px;border-radius:6px;padding:2px 6px;font-size:12px;color:#a8c7e6}
  .modal{position:fixed;inset:0;display:none;place-items:center;background:rgba(3,8,14,0.5);backdrop-filter:blur(2px);z-index:50}
  .card{width:min(560px,92vw);background:#0f1722;border:1px solid #233a57;border-radius:14px;box-shadow:0 20px 60px rgba(0,0,0,.45)}
  .card header{padding:12px 14px;border-bottom:1px solid #1c2f46;display:flex;justify-content:space-between;align-items:center}
  .card header h2{margin:0;font-size:16px;color:#daf1ff}
  .x{cursor:pointer;border:1px solid #21344d;border-radius:8px;padding:2px 6px;font-size:12px}
  .card section{padding:12px 14px;display:grid;gap:10px}
  .choice{border:1px solid #254464;background:#0d1a28;border-radius:10px;padding:10px;display:flex;gap:10px;align-items:center;justify-content:space-between}
  .choice .info{font-size:13px}
  .choice button{border:1px solid #285a86;background:#102538;color:#cce8ff;border-radius:8px;padding:6px 10px;cursor:pointer}
  .choice button.danger{border-color:#6b2f2f;background:#221014;color:#ffb9b9}
  .label{font-size:12px;color:#9ec3df}
  .toast{position:fixed;left:50%;transform:translateX(-50%);top:16px;background:#0e1927;border:1px solid #1d2f47;color:#cde9ff;padding:8px 12px;border-radius:10px;font-size:13px;display:none;z-index:60}
  .over{position:fixed;inset:0;display:none;place-items:center;background:rgba(8,10,16,.6);z-index:70}
  .over .panel{background:#0f1622;border:1px solid #20344c;padding:16px 20px;border-radius:14px;color:#d8ebff;text-align:center}
  .over .panel button{margin-top:10px;border:1px solid #2a4e77;background:#10253a;color:#d8ebff;padding:8px 12px;border-radius:10px;cursor:pointer}
  
  /* Menu Styles */
  .screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background: rgba(11, 20, 31, 0.9);
    z-index: 100;
  }
  
  .hidden { display: none; }
  
  .menu-container {
    background: #0f1622;
    border: 1px solid #2a4e77;
    border-radius: 14px;
    padding: 2rem;
    max-width: 500px;
    width: 90%;
    text-align: center;
  }
  
  .menu-title {
    color: #67d4ff;
    font-size: 2.5rem;
    margin-bottom: 2rem;
    text-shadow: 0 0 10px rgba(103, 212, 255, 0.3);
  }
  
  .menu-button {
    display: block;
    width: 100%;
    padding: 12px 24px;
    margin: 8px 0;
    background: #1a2d43;
    border: 1px solid #2a4e77;
    color: #e5f3ff;
    border-radius: 8px;
    cursor: pointer;
    font-size: 1.1rem;
    transition: all 0.2s ease;
  }
  
  .menu-button:hover {
    background: #2a4e77;
    transform: translateY(-2px);
  }
  
  .back-button {
    margin-top: 1.5rem;
    background: transparent;
    border: 1px solid #2a4e77;
  }
  
  .instructions {
    text-align: left;
    margin: 1rem 0;
    line-height: 1.6;
  }
  
  .instructions h3 {
    color: #67d4ff;
    margin: 1rem 0 0.5rem 0;
  }
  
  .instructions p {
    margin: 0.5rem 0;
  }
</style>
</head>
<body>
<!-- Main Menu -->
<div id="main-menu" class="screen">
  <div class="menu-container">
    <h1 class="menu-title">SCRAP TITANS</h1>
    <button id="btn-start" class="menu-button">START GAME</button>
    <button id="btn-how-to-play" class="menu-button">HOW TO PLAY</button>
    <button id="btn-credits" class="menu-button">CREDITS</button>
  </div>
</div>

<!-- How to Play Screen -->
<div id="how-to-play" class="screen hidden">
  <div class="menu-container">
    <h2 class="menu-title">HOW TO PLAY</h2>
    <div class="instructions">
      <h3>MOVEMENT</h3>
      <p><span class="kbd">A / D</span> Move Left/Right</p>
      <p><span class="kbd">SPACE</span> Jump</p>
      <p><span class="kbd">MOUSE</span> Aim</p>
      
      <h3>COMBAT</h3>
      <p><span class="kbd">LEFT CLICK</span> Shoot</p>
      <p><span class="kbd">Q</span> Reload</p>
      <p><span class="kbd">E</span> Open Crates</p>
      
      <h3>OBJECTIVE</h3>
      <p>Navigate through levels, defeat enemies, and collect upgrades from crates to become the ultimate Scrap Titan!</p>
    </div>
    <button id="back-from-how-to-play" class="menu-button back-button">BACK TO MENU</button>
  </div>
</div>

<!-- Credits Screen -->
<div id="credits" class="screen hidden">
  <div class="menu-container">
    <h2 class="menu-title">CREDITS</h2>
    <div class="instructions">
      <p><strong>Scrap Titans</strong> is a robot platformer game created with HTML5, CSS3, and JavaScript.</p>
      <p>All game assets and code were created specifically for this project.</p>
      <p>Sound effects generated with Web Audio API.</p>
      <p>© 2025 Scrap Titans Team</p>
    </div>
    <button id="back-from-credits" class="menu-button back-button">BACK TO MENU</button>
  </div>
</div>

<!-- Game Container -->
<div id="wrap" class="hidden">
  <canvas id="game" width="960" height="540"></canvas>
  <div class="hud">
    <span class="chip"><b>Scrap Titans</b></span>
    <div class="sep"></div>
    <span class="chip">Lvl <b id="lvl">1</b></span>
    <span class="chip">Lives <b id="lives">5</b></span>
    <span class="chip">Score <b class="score" id="score">0</b></span>
    <span class="chip">Dist <b id="dist">0</b> m</span>
    <span class="chip">Ammo <b id="ammo">7/7</b></span>
    <span class="chip" id="reloadChip" style="display:none">Reloading…</span>
    <span class="chip">Crates <b id="crates">0</b></span>
    <span class="chip">Kills <b id="kills">0</b></span>
    <div class="sep"></div>
    <div class="bar"><i id="hpBar" style="width:100%"></i></div>
    <span class="chip">Head: <b id="slotHead">—</b></span>
    <span class="chip">Torso: <b id="slotTorso">Light Torso</b></span>
    <span class="chip">L-Arm: <b id="slotLeft">—</b></span>
    <span class="chip">R-Arm: <b id="slotRight">Blaster Arm</b></span>
    <span class="chip">Legs: <b id="slotLegs">Sprinter Legs</b></span>
  </div>
  <div class="help">
    <span class="kbd">A / D</span> move
    <span class="kbd">Space</span> jump (hold = higher)
    <span class="kbd">Mouse</span> aim · <span class="kbd">L-Click</span> fire
    <span class="kbd">Q</span> reload
    <span class="kbd">E</span> open crate
    <span class="kbd">R</span> restart
  </div>
</div>

<div class="modal" id="modal">
  <div class="card">
    <header><h2 id="modalTitle">Mystery Crate</h2><div class="x" id="closeModal">✕</div></header>
    <section>
      <div id="modalDesc" class="label">Choose a sacrifice first. The part will be revealed <b>after</b> your choice.</div>
      <div id="choices"></div>
    </section>
  </div>
</div>

<div class="toast" id="toast"></div>

<div class="over" id="over">
  <div class="panel">
    <h2 style="margin:0 0 6px 0;">Game Over</h2>
    <div id="overMsg" style="opacity:.85;margin-bottom:8px;">Out of lives.</div>
    <button id="btnRestart">Restart</button>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('game'), ctx = canvas.getContext('2d');
  function fit(){const w=innerWidth,h=innerHeight,t=16/9;let cw,ch;if(w/h>t){ch=h;cw=h*t}else{cw=w;ch=w/t}canvas.style.width=cw+'px';canvas.style.height=ch+'px';canvas.style.imageRendering='pixelated';}
  addEventListener('resize',fit);fit();

  const ui = {
    hpBar: gid('hpBar'),
    slots: { head:gid('slotHead'), torso:gid('slotTorso'), leftArm:gid('slotLeft'), rightArm:gid('slotRight'), legs:gid('slotLegs') },
    dist: gid('dist'), crates: gid('crates'), kills: gid('kills'), score: gid('score'),
    ammo: gid('ammo'), reloadChip: gid('reloadChip'),
    modal: gid('modal'), modalTitle: gid('modalTitle'), modalDesc: gid('modalDesc'), choices: gid('choices'), close: gid('closeModal'),
    toast: gid('toast'),
    over: gid('over'), overMsg: gid('overMsg'), btnRestart: gid('btnRestart'),
    lvl: gid('lvl'), lives: gid('lives')
  };
  ui.close.addEventListener('click', ()=>closeModal());
  ui.btnRestart.addEventListener('click', ()=> hardRestart());
  function gid(id){return document.getElementById(id)}
  function toast(m,ms=1500){ui.toast.textContent=m;ui.toast.style.display='block';setTimeout(()=>ui.toast.style.display='none',ms);}

  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const rand=(a,b)=>Math.random()*(b-a)+a, randi=(a,b)=>Math.floor(rand(a,b+1));
  const aabb=(a,b)=>a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y;

  const EPS = 0.001;

  const keys={}; addEventListener('keydown',e=>{keys[e.key.toLowerCase()]=true; if(e.key.toLowerCase()==='r') hardRestart();}); addEventListener('keyup',e=>keys[e.key.toLowerCase()]=false);
  const mouse={x:0,y:0,down:false}; addEventListener('mousedown',()=>mouse.down=true); addEventListener('mouseup',()=>mouse.down=false);
  canvas.addEventListener('mousemove',e=>{const r=canvas.getBoundingClientRect(),sx=canvas.width/r.width,sy=canvas.height/r.height;mouse.x=(e.clientX-r.left)*sx;mouse.y=(e.clientY-r.top)*sy;});

  const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  function beep(f=440, t=0.08, type='sine', vol=0.2){
    const o=audioCtx.createOscillator(), g=audioCtx.createGain();
    o.type=type; o.frequency.value=f; g.gain.value=vol;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + t);
    o.stop(audioCtx.currentTime + t + 0.02);
  }
  const sfx = {
    jump: ()=>beep(320,0.09,'square',0.15),
    shoot: ()=>beep(900,0.03,'triangle',0.12),
    reload: ()=>{beep(280,0.06,'sawtooth',0.12); setTimeout(()=>beep(520,0.05,'triangle',0.12),70);},
    crate: ()=>beep(700,0.12,'sine',0.18),
    death: ()=>{beep(140,0.12,'square',0.2); setTimeout(()=>beep(90,0.2,'sawtooth',0.18),120);},
    level: ()=>{beep(660,0.07,'sine',0.14); setTimeout(()=>beep(880,0.07,'sine',0.14),80); setTimeout(()=>beep(990,0.08,'sine',0.14),160);}
  };

  // Enemy types with different behaviors and stats
  const ENEMY_TYPES = {
    WALKER: {
      name: 'Walker',
      width: 22, height: 22, speed: 0.8, health: 40, color: '#ff7b7b',
      score: 100, attack: 10, jumpPower: 0, shootCooldown: 0
    },
    JUMPER: {
      name: 'Jumper',
      width: 20, height: 20, speed: 0.6, health: 30, color: '#7bff7b',
      score: 150, attack: 15, jumpPower: 12, jumpCooldown: 2, shootCooldown: 0
    },
    TANK: {
      name: 'Tank',
      width: 30, height: 30, speed: 0.3, health: 100, color: '#ff7b00',
      score: 250, attack: 20, jumpPower: 0, shootCooldown: 0
    },
    SHOOTER: {
      name: 'Shooter',
      width: 24, height: 24, speed: 0.4, health: 25, color: '#7b9eff',
      score: 200, attack: 15, jumpPower: 0, shootCooldown: 2, bulletSpeed: 4, bulletColor: '#7b9eff'
    }
  };

  const world = {
    w:canvas.width,h:canvas.height,paused:false, cam:{x:0,y:0}, gravity:0.58,
    enemies:[], bullets:[], platforms:[], movers:[], spikes:[], gate:null, cratesArr:[],
    distance:0, score:0, cratesOpened:0, kills:0, hitEffects: [],
    level:1, levelLength: 2600, levelStartX: 0, checkpoint:{x:40,y:420}, lives:5, time: 0
  };

  const PARTS={
    head:[
      {slot:'head',name:'Sensor Head',desc:'+5% aim assist.',stats:{},aimAssist:0.05, art:'sensor'},
      {slot:'head',name:'Armor Head',desc:'+10 armor.',stats:{armor:10},art:'armor'},
      {slot:'head',name:'Targeting Head',desc:'+10% fire rate.',stats:{firerate:0.10},art:'target'},
      {slot:'head',name:'Tactical Visor',desc:'+15% damage, +5% fire rate',stats:{dmg:0.15,firerate:0.05},art:'tactical'},
      {slot:'head',name:'Recon Scope',desc:'+10% aim assist, +5% speed',stats:{speed:0.05},aimAssist:0.10,art:'recon'}
    ],
    torso:[{slot:'torso',name:'Light Torso',desc:'+50 HP, +5% speed.',stats:{hp:50,speed:0.05},art:'light'},
           {slot:'torso',name:'Heavy Torso',desc:'+100 HP, -10% speed.',stats:{hp:100,speed:-0.10},art:'heavy'},
           {slot:'torso',name:'Reactive Torso',desc:'+60 HP. 10% reflect.',stats:{hp:60},reflect:0.10,art:'reactive'}],
    leftArm:[{slot:'leftArm',name:'Shield Arm',desc:'-30% incoming damage.',stats:{},dmgReduce:0.30,art:'shield'},
             {slot:'leftArm',name:'Repair Arm',desc:'Slow auto-repair out of combat.',stats:{},regen:1.6,art:'repair'},
             {slot:'leftArm',name:'Pulse Arm',desc:'On hit: radial knockback.',stats:{},pulse:true,art:'pulse'}],
    rightArm:[{slot:'rightArm',name:'Blaster Arm',desc:'Balanced pew-pew.',stats:{dmg:14,rof:7,spread:0.03,mag:7,reload:1.0},art:'blaster'},
              {slot:'rightArm',name:'Rail Arm',desc:'High dmg, slow ROF, pierces.',stats:{dmg:38,rof:2,pierce:true,spread:0.006,mag:3,reload:1.4},art:'rail'},
              {slot:'rightArm',name:'Scatter Arm',desc:'Shotgun burst.',stats:{dmg:7,rof:3,pellets:7,spread:0.18,mag:5,reload:1.1},art:'scatter'}],
    legs:[{slot:'legs',name:'Sprinter Legs',desc:'+20% speed.',stats:{speed:0.20},art:'sprinter'},
          {slot:'legs',name:'Mag Boots',desc:'-5% speed, +20% knockback resist.',stats:{speed:-0.05,kbResist:0.20},art:'mag'},
          {slot:'legs',name:'Treads',desc:'-10% speed, +15 armor.',stats:{speed:-0.10,armor:15},art:'treads'}]
  };
  const sprite = { canvas:document.createElement('canvas'), dirty:true };
  sprite.canvas.width=64; sprite.canvas.height=64;

  function circle(ctx,x,y,r){ctx.beginPath();ctx.arc(x,y,r,0,Math.PI*2);}
  function rounded(ctx,x,y,w,h,r){ctx.beginPath();ctx.moveTo(x+r,y);ctx.arcTo(x+w,y,x+w,y+h,r);ctx.arcTo(x+w,y+h,x,y+h,r);ctx.arcTo(x,y+h,x,y,r);ctx.arcTo(x,y,x+w,y,r);ctx.closePath();}
  function drawPart(ctx, kind, x=32, y=36){
    ctx.save(); ctx.translate(x,y);
    if(kind==='torso:light'){ ctx.fillStyle='#1f3a57'; rounded(ctx,-16,-18,32,36,6); ctx.fill(); }
    if(kind==='torso:heavy'){ ctx.fillStyle='#16314c'; rounded(ctx,-18,-20,36,40,8); ctx.fill(); }
    if(kind==='torso:reactive'){ ctx.fillStyle='#214665'; rounded(ctx,-16,-18,32,36,6); ctx.fill(); ctx.strokeStyle='#68d7ff'; ctx.lineWidth=2; ctx.strokeRect(-10,-12,20,24); }
    if(kind==='head:sensor'){ ctx.fillStyle='#2b4f75'; circle(ctx,0,-24,7); ctx.fill(); ctx.fillStyle='#86e7ff'; circle(ctx,0,-24,3); ctx.fill(); }
    if(kind==='head:armor'){ ctx.fillStyle='#244b70'; rounded(ctx,-9,-31,18,14,4); ctx.fill(); }
    if(kind==='head:target'){ ctx.fillStyle='#2b4f75'; circle(ctx,0,-24,7); ctx.fill(); ctx.strokeStyle='#86e7ff'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(-10,-24); ctx.lineTo(10,-24); ctx.moveTo(0,-34); ctx.lineTo(0,-14); ctx.stroke(); }
    if(kind==='larm:shield'){ ctx.fillStyle='#2d5d86'; rounded(ctx,-24,-6,10,12,3); ctx.fill(); ctx.fillStyle='#86c8ff'; rounded(ctx,-30,-10,8,20,3); ctx.fill(); }
    if(kind==='larm:repair'){ ctx.fillStyle='#2d5d86'; rounded(ctx,-24,-6,10,12,3); ctx.fill(); ctx.fillStyle='#55efc4'; ctx.fillRect(-30,-4,6,8); }
    if(kind==='larm:pulse'){ ctx.fillStyle='#2d5d86'; rounded(ctx,-24,-6,10,12,3); ctx.fill(); ctx.strokeStyle='#ffd166'; ctx.beginPath(); ctx.arc(-28,0,6,0,Math.PI*2); ctx.stroke(); }
    if(kind==='rarm:blaster'){ ctx.fillStyle='#2d5d86'; rounded(ctx,14,-6,10,12,3); ctx.fill(); ctx.fillStyle='#68d7ff'; rounded(ctx,22,-3,12,6,2); ctx.fill(); }
    if(kind==='rarm:rail'){ ctx.fillStyle='#294e75'; rounded(ctx,12,-7,12,14,3); ctx.fill(); ctx.fillStyle='#a9ddff'; ctx.fillRect(22,-5,16,10); }
    if(kind==='rarm:scatter'){ ctx.fillStyle='#2d5d86'; rounded(ctx,12,-7,12,14,3); ctx.fill(); for(let i=-1;i<=1;i++){ ctx.fillRect(18+i*3,-4,10,3); } }
    if(kind==='legs:sprinter'){ ctx.fillStyle='#2b4666'; rounded(ctx,-10,18,20,6,3); ctx.fill(); }
    if(kind==='legs:mag'){ ctx.fillStyle='#27425f'; rounded(ctx,-12,18,24,6,3); ctx.fill(); ctx.fillStyle='#86c8ff'; ctx.fillRect(-12,23,24,2); }
    if(kind==='legs:treads'){ ctx.fillStyle='#1a3048'; rounded(ctx,-12,18,24,6,3); ctx.fill(); ctx.fillStyle='#3a5b7a'; for(let i=-10;i<=10;i+=5) ctx.fillRect(i,20,2,4); }
    ctx.restore();
  }
  function rebuildSprite(){
    const s=sprite.canvas, g=s.getContext('2d'); g.clearRect(0,0,s.width,s.height);
    const parts = player.parts;
    drawPart(g, 'legs:'+(parts.legs?.art||'sprinter'));
    drawPart(g, 'torso:'+(parts.torso?.art||'light'));
    drawPart(g, 'larm:'+(parts.leftArm?.art||'repair'));
    drawPart(g, 'rarm:'+(parts.rightArm?.art||'blaster'));
    drawPart(g, 'head:'+(parts.head?.art||'sensor'));
    sprite.dirty=false;
  }

  const player={
    x:40,y:420,w:26,h:34,vx:0,vy:0,prevX:40,prevY:420,
    onGround:false, standingOn:null, facing:1,
    base:{hp:150,speed:2.8,armor:0,firerate:0,dmg:12,kbResist:0},
    hp: 100,
    maxHp: 100,
    invincible: false,
    invincibleTimer: 0,
    hp:150,maxhp:150,
    parts:{head:null,torso:null,leftArm:null,rightArm:null,legs:null},
    fireCooldown:0,aimAssist:0,reflect:0,dmgReduce:0,regen:0,
    jumpVel:-11.0, lowJumpGravity:0.50, coyoteTime:0.16, jumpBuffer:0.18, coyote:0, buffer:0,
    footProbe:10,
    ammo:7, mag:7, reloadTime:1.0, reloading:false, reloadT:0,
    stickTimer:0
  };
  function equip(p){player.parts[p.slot]=p; recalc(); sprite.dirty=true;}
  function unequip(slot){player.parts[slot]=null; recalc(); sprite.dirty=true;}
  function recalc(){
    let hp=150,speed=1,armor=0,fr=0,dmg=12,kb=0,aim=0,ref=0,red=0,rg=0,mag=7,rt=1.0;
    Object.values(player.parts).forEach(p=>{if(!p)return;const s=p.stats||{};if(s.hp)hp+=s.hp;if(s.speed)speed+=s.speed;if(s.armor)armor+=s.armor;if(s.firerate)fr+=s.firerate;if(s.dmg)dmg=Math.max(dmg,s.dmg);if(s.kbResist)kb+=s.kbResist;if(s.mag)mag=s.mag;if(s.reload)rt=s.reload;if(p.aimAssist)aim+=p.aimAssist;if(p.reflect)ref+=p.reflect;if(p.dmgReduce)red=Math.max(red,p.dmgReduce);if(p.regen)rg+=p.regen;});
    player.maxhp=hp;if(player.hp>player.maxhp)player.hp=player.maxhp;
    player.base.speed=2.8*speed; player.base.armor=armor; player.base.firerate=fr; player.base.dmg=dmg; player.base.kbResist=kb;
    player.aimAssist=aim; player.reflect=ref; player.dmgReduce=red; player.regen=rg;
    player.mag=mag; player.reloadTime=rt; if(player.ammo>player.mag) player.ammo=player.mag;
    ui.hpBar.style.width=Math.max(4,(player.hp/player.maxhp)*100)+'%';
    for(const k of Object.keys(ui.slots)){ui.slots[k].textContent=player.parts[k]?.name ?? '—';}
    ui.ammo.textContent = player.ammo+'/'+player.mag;
  }
  equip({slot:'torso',...{name:'Light Torso',stats:{hp:50,speed:0.05},art:'light'}});
  equip({slot:'rightArm',...{name:'Blaster Arm',stats:{dmg:14,rof:7,spread:0.03,mag:7,reload:1.0},art:'blaster'}});
  equip({slot:'legs',...{name:'Sprinter Legs',stats:{speed:0.20},art:'sprinter'}});
  rebuildSprite();

  function diff(){ return 1 + (world.level-1)*0.15; }
  function maxRise(){ const v0 = -player.jumpVel, g=world.gravity; return (v0*v0)/(2*g); }
  function adjustNy(y,ny){ const rise = maxRise()*0.80, maxDrop = 120; return Math.min(y + maxDrop, Math.max(ny, y - rise)); }
  function maxHorizontalReach(dy){ const g=world.gravity, v0=-player.jumpVel, A=0.5*g, B=-v0, C=-dy, disc=Math.max(0,B*B-4*A*C); const t=( -B + Math.sqrt(disc) )/(2*A); const vxMax=player.base.speed+1.0; return Math.max(110, vxMax*t*0.92); }
  function reachableGap(y,ny){ const dy=ny-y, allowed=Math.floor(maxHorizontalReach(dy)), d=diff(); const baseMin=110, baseMax=Math.min(200+Math.floor((d-1)*20), allowed-14); return Math.max(baseMin, randi(baseMin, Math.max(baseMin+10, baseMax))); }
  function canSpawnEnemyOn(p){ const px1=player.x-220, px2=player.x+player.w+220; const overlap=!(p.x+p.w<px1 || p.x>px2); const same=(player.standingOn===p) || (player.prevY+player.h<=p.y && player.y+player.h>=p.y && player.x+player.w>p.x && player.x<p.x+p.w); return !overlap && !same; }

  function buildLevel(){
    world.platforms.length=0; world.movers.length=0; world.enemies.length=0; world.spikes.length=0; world.bullets.length=0; world.cratesArr.length=0;
    const startX=world.levelStartX, endX=startX+world.levelLength;
    const startPlat = {x:startX, y:500, w:360, h:40, col:'#132438'}; world.platforms.push(startPlat);
    world.checkpoint = {x:startX+40, y:500-34};
    let x=startX+340, y=460; const minY=220, maxY=500;
    let fieldCrateCount=0, maxFieldCrates=2;
    while(x<endX-240){
      let ny = adjustNy(y, y + randi(-60,90)); ny = Math.max(minY, Math.min(maxY, ny));
      const gap=reachableGap(y,ny);
      const px=x+gap, py=ny; let w=randi(120,230);
      const useMover = Math.random() < (0.12 + (diff()-1)*0.05);
      if(useMover){
        const vertical=Math.random()<0.5;
        if(vertical){
          w=Math.max(w,160);
          const speedPix=Math.min(60, 40*diff());
          const amp=randi(18,36);
          const crossTime=(w+80)/(player.base.speed*60);
          const dwell=Math.max(0.7, crossTime*1.2);
          world.movers.push({x:px,y:py,w:w,h:14,axis:'v',col:'#1b3854',dx:0,dy:0,baseY:py,minY:py-amp,maxY:py+amp,dir:-1,speedPix,dwell,dwellT:0});
        } else {
          const speedPix = 40*diff(), amp=randi(30,60);
          world.movers.push({x:px,y:py,w:w,h:14,axis:'h',col:'#1b3854',dx:0,dy:0,baseX:px,minX:px-amp,maxX:px+amp,dir:1,speedPix});
        }
      } else {
        const plat = {x:px,y:py,w:w,h:14,col:'#112133'};
        world.platforms.push(plat);
        // Chance to spawn a field crate on this static platform (not too close to start)
        const eligible = (px > startX + 520);
        if(eligible && fieldCrateCount < maxFieldCrates && Math.random() < 0.10){
          const cx = clamp(px + randi(16, Math.max(16, w-32)), px+16, px+w-28);
          world.cratesArr.push({x:cx, y:py-20, w:18, h:18, taken:false});
          fieldCrateCount++;
        }
      }
      // Enemies
      const pad = {x:px,y:py,w:w,h:14};
      if(Math.random() < (0.11 + (diff()-1)*0.06) && canSpawnEnemyOn(pad)){
        // Randomly select enemy type based on level
        let enemyType;
        const r = Math.random();
        const level = world.level;
        
        if (level > 5 && r > 0.8) {
          enemyType = 'SHOOTER';
        } else if (level > 3 && r > 0.6) {
          enemyType = 'TANK';
        } else if (level > 2 && r > 0.4) {
          enemyType = 'JUMPER';
        } else {
          enemyType = 'WALKER';
        }
        
        const type = ENEMY_TYPES[enemyType];
        const enemy = {
          type: enemyType,
          x: pad.x + 20,
          y: pad.y - type.height,
          w: type.width,
          h: type.height,
          vx: (type.speed * (Math.random() > 0.5 ? 1 : -1)) * (0.8 + Math.random() * 0.4) * diff(),
          vy: 0,
          hp: type.health,
          maxHp: type.health,
          hitTimer: 0,
          pad: pad,
          jumpCooldown: 0,
          shootCooldown: 0,
          ...type
        };
        
        world.enemies.push(enemy);
      }
      x = px + w; y = ny;
    }
    world.gate = {x:endX-80, y:280, w:24, h:220};
    world.spikes.push({x:startX, y:world.h-18, w:endX-startX, h:18});
  }

  function randomPart(){ const pools=['head','torso','leftArm','rightArm','legs']; const which=pools[randi(0,4)]; return PARTS[which][randi(0,2)]; }
  let modalMode = 'gate'; // 'gate' or 'field'
  function openModal(mode='gate'){
    modalMode = mode;
    world.paused=true;
    ui.modalTitle.textContent = mode==='gate' ? ('Level '+world.level+' Reward') : 'Field Crate';
    ui.modalDesc.innerHTML='Choose a sacrifice. The part will be revealed <b>after</b> your choice.';
    ui.choices.innerHTML='';
    const add=(label,fn,danger=false)=>{const row=document.createElement('div');row.className='choice';row.innerHTML=`<div class="info">${label}</div>`;const b=document.createElement('button');b.textContent=danger?'Sacrifice':'Choose';if(danger)b.classList.add('danger');b.onclick=fn;row.appendChild(b);ui.choices.appendChild(row);};
    for(const slot of ['head','torso','leftArm','rightArm','legs']){ const cur=player.parts[slot]; if(cur){ add(`<b>Remove ${cur.name}</b> (slot: <b>${slot}</b>) to receive a <b>random part</b>.`,()=>{ commitSacrifice({type:'remove',slot}); }); } }
    add(`Pay <b>-10% Max HP</b> to receive a <b>random part</b>.`,()=>{ commitSacrifice({type:'hp'}); }, true);
    ui.modal.style.display='grid';
  }
  function commitSacrifice(choice){
    const part = randomPart();
    if(choice.type==='remove'){ unequip(choice.slot); }
    else { const pen=Math.floor(player.maxhp*0.10); player.maxhp=Math.max(40,player.maxhp-pen); if(player.hp>player.maxhp) player.hp=player.maxhp; ui.hpBar.style.width=Math.max(4,(player.hp/player.maxhp)*100)+'%'; }
    equip(part); toast('You got: '+part.name); sfx.crate(); closeModal();
    world.cratesOpened++; document.getElementById('crates').textContent=world.cratesOpened;
    if(modalMode==='gate'){ nextLevel(); }
  }
  function closeModal(){ui.modal.style.display='none';world.paused=false;}

  function tryReload(){ if(player.reloading) return; if(player.ammo===player.mag) return; player.reloading=true; player.reloadT=player.reloadTime; ui.reloadChip.style.display='inline-block'; sfx.reload(); }
  addEventListener('keydown',(e)=>{ if(e.key.toLowerCase()==='q'){ tryReload(); }});

  function fire(dt){
    const weapon=player.parts.rightArm; if(!weapon) return;
    let rof=(weapon.stats.rof||5)*(1+(player.base.firerate||0));
    player.fireCooldown-=dt;
    if(player.reloading){
      player.reloadT-=dt; if(player.reloadT<=0){ player.reloading=false; player.ammo=player.mag; ui.reloadChip.style.display='none'; ui.ammo.textContent=player.ammo+'/'+player.mag; }
      return;
    }
    if(mouse.down && player.fireCooldown<=0){
      if(player.ammo<=0){ tryReload(); return; }
      player.ammo--; ui.ammo.textContent = player.ammo+'/'+player.mag;
      player.fireCooldown=1/rof;
      const dmg=weapon.stats.dmg||player.base.dmg, pellets=weapon.stats.pellets||1, spread=weapon.stats.spread||0.02, pierce=!!weapon.stats.pierce;
      const ang=Math.atan2(mouse.y-(player.y+player.h/2), mouse.x-(player.x+player.w/2 - world.cam.x));
      for(let i=0;i<pellets;i++){
        const a=ang + (Math.random()*2-1)*spread*(1-(player.aimAssist||0)), sp=9.0;
        world.bullets.push({x:player.x+player.w/2+Math.cos(a)*14,y:player.y+player.h/2+Math.sin(a)*14,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,dmg, pierce, life:1.6});
      }
      sfx.shoot();
      if(player.ammo===0) tryReload();
    }
  }

  function updateEnemy(e, dt) {
    // Update cooldowns
    if (e.jumpCooldown > 0) e.jumpCooldown -= dt;
    if (e.shootCooldown > 0) e.shootCooldown -= dt;
    
    // Enemy-specific behavior
    switch(e.type) {
      case 'WALKER':
        e.x += e.vx * 2.0;
        if (e.x < e.pad.x || e.x + e.w > e.pad.x + e.pad.w) e.vx *= -1;
        break;
        
      case 'JUMPER':
        if (e.onGround && e.jumpCooldown <= 0) {
          e.vy = -e.jumpPower;
          e.jumpCooldown = 2 + Math.random() * 2;
        }
        e.x += e.vx * 1.5;
        if (e.x < e.pad.x || e.x + e.w > e.pad.x + e.pad.w) e.vx *= -1;
        break;
        
      case 'TANK':
        e.x += e.vx * 1.0;
        if (e.x < e.pad.x || e.x + e.w > e.pad.x + e.pad.w) e.vx *= -1;
        // Tanks can push other enemies
        for (const other of world.enemies) {
          if (other !== e && aabb({
            x: e.x + e.vx * 10,
            y: e.y,
            w: e.w,
            h: e.h
          }, other)) {
            other.x += e.vx * 5 * dt;
          }
        }
        break;

      case 'SHOOTER':
        e.x += e.vx * 1.2;
        if (e.x < e.pad.x || e.x + e.w > e.pad.x + e.pad.w) e.vx *= -1;
        
        // Shoot at player if in range
        if (e.shootCooldown <= 0 && Math.abs(e.y - player.y) < 100) {
          const dx = (player.x + player.w/2) - (e.x + e.w/2);
          const dy = (player.y + player.h/2) - (e.y + e.h/2);
          const dist = Math.sqrt(dx*dx + dy*dy);
          
          if (dist < 300) { // Shooting range
            const angle = Math.atan2(dy, dx);
            world.bullets.push({
              x: e.x + e.w/2,
              y: e.y + e.h/2,
              vx: Math.cos(angle) * e.bulletSpeed,
              vy: Math.sin(angle) * e.bulletSpeed,
              dmg: e.attack,
              life: 2.0,
              fromEnemy: true,
              color: e.bulletColor
            });
            e.shootCooldown = e.shootCooldown || 2.0;
            
            // Visual feedback for shooting
            for (let i = 0; i < 3; i++) {
              const angle = Math.random() * Math.PI * 2;
              world.hitEffects.push({
                x: e.x + e.w/2,
                y: e.y + e.h/2,
                vx: Math.cos(angle) * 2,
                vy: Math.sin(angle) * 2,
                life: 0.3 + Math.random() * 0.3,
                color: e.bulletColor
              });
            }
          }
        }
        break;
    }
    
    // Update hit effect timer
    if (e.hitTimer > 0) {
      e.hitTimer -= dt;
      if (e.hitTimer <= 0) {
        e.hitTimer = 0;
      }
    }
    
    // Apply gravity and update position
    e.vy = Math.min(e.vy + world.gravity, 10);
    e.y += e.vy;
    
    // Check if enemy fell off the platform
    if (e.y > world.h + 100) {
      e.hp = 0; // Mark for removal
    }
  }

  function updateMovers(dt){
    for(const m of world.movers){
      const ox=m.x, oy=m.y;
      if(m.axis==='v'){
        if(m.dwellT>0){ m.dwellT -= dt; m.dx=0; m.dy=0; continue; }
        m.y += m.dir * m.speedPix * dt;
        if(m.y <= m.minY){ m.y = m.minY; m.dir = 1; m.dwellT = m.dwell; }
        if(m.y >= m.maxY){ m.y = m.maxY; m.dir = -1; m.dwellT = m.dwell; }
      } else {
        m.x += m.dir * m.speedPix * dt;
        if(m.x <= m.minX){ m.x = m.minX; m.dir = 1; }
        if(m.x >= m.maxX){ m.x = m.maxX; m.dir = -1; }
      }
      m.dx = m.x - ox; m.dy = m.y - oy;
    }
  }

  function collideStage(ent){
    ent.onGround=false; ent.standingOn=null;
    function collideRect(r){
      const prevBottom = ent.prevY + ent.h, currBottom = ent.y + ent.h;
      if(ent.prevX + ent.w > r.x+EPS && ent.prevX < r.x + r.w-EPS && prevBottom <= r.y + 2 && currBottom >= r.y && ent.vy >= 0){
        ent.y = r.y - ent.h; ent.vy = 0; ent.onGround = true; ent.standingOn = r; ent.stickTimer = 0.10;
      }
      if(ent.prevX + ent.w > r.x+EPS && ent.prevX < r.x + r.w-EPS && ent.prevY >= r.y + r.h && ent.y <= r.y + r.h && ent.vy < 0){
        ent.y = r.y + r.h; ent.vy = 0;
      }
      if(ent.y + ent.h > r.y+EPS && ent.y < r.y + r.h-EPS){
        if(ent.prevX + ent.w <= r.x && ent.x + ent.w > r.x){ ent.x = r.x - ent.w; ent.vx = 0; }
        if(ent.prevX >= r.x + r.w && ent.x < r.x + r.w){ ent.x = r.x + r.w; ent.vx = 0; }
      }
    }
    for(const p of world.platforms) collideRect(p);
    for(const m of world.movers) collideRect(m);
    if(ent.y+ent.h>world.h){ ent.y=world.h-ent.h; ent.vy=0; ent.onGround=true; }
  }

  function groundSnap(ent){
    if(ent.vy < 0) return;
    const feet = ent.y + ent.h, probe = ent.footProbe || 6;
    let best = null, bestY = Infinity;
    function consider(s){ if(ent.x + ent.w <= s.x || ent.x >= s.x + s.w) return; if(s.y >= feet && s.y - feet <= probe){ if(s.y<bestY){bestY=s.y; best=s;} } }
    for(const p of world.platforms) consider(p);
    for(const m of world.movers)    consider(m);
    if(best){ ent.y = bestY - ent.h; ent.vy = 0; ent.onGround = true; ent.standingOn = best; ent.stickTimer = Math.max(ent.stickTimer, 0.08); }
  }

  function stickyRide(ent){
    if(!ent.standingOn) return;
    const r = ent.standingOn;
    if(typeof r.dx === 'number'){ ent.x += r.dx; }
    if(typeof r.dy === 'number'){ ent.y += r.dy; }
    const feet = ent.y + ent.h;
    const onTop = Math.abs(feet - r.y) <= 2.0 + EPS;
    const withinX = ent.x + ent.w > r.x + 3 && ent.x < r.x + r.w - 3;
    if(onTop && withinX && ent.vy >= 0){
      ent.y = r.y - ent.h; ent.vy = 0; ent.onGround = true;
      ent.stickTimer = Math.max(ent.stickTimer, 0.06);
    } else {
      if(ent.stickTimer > 0 && ent.x + ent.w > r.x - 2 && ent.x < r.x + r.w + 2 && feet <= r.y + 6){
        ent.y = r.y - ent.h; ent.vy = 0; ent.onGround = true;
      } else {
        ent.standingOn = null;
      }
    }
  }

  function kill(){
    sfx.death(); world.lives--; ui.lives.textContent = world.lives;
    if(world.lives<=0){ world.paused=true; ui.over.style.display='grid'; return; }
    player.x = world.checkpoint.x; player.y = world.checkpoint.y; player.vx=0; player.vy=0; player.onGround=false; player.standingOn=null; world.bullets.length=0; world.cam.x = Math.max(world.levelStartX, player.x - 200);
    // Reset HP on respawn
    player.hp = player.maxHp;
    ui.hpBar.style.width = '100%';
    // Reset invincibility
    player.invincible = false;
    player.invincibleTimer = 0;
    if(player.sprite) player.sprite.alpha = 1.0;
  }

  // Open field crate with E when overlapping
  addEventListener('keydown', (e)=>{
    if(e.key.toLowerCase() === 'e' && !world.paused){
      const pbox = {x:player.x, y:player.y, w:player.w, h:player.h};
      const near = world.cratesArr.find(c=>!c.taken && aabb(pbox,{x:c.x-6,y:c.y-2,w:c.w+12,h:c.h+10}));
      if(near){ near.taken=true; openModal('field'); }
      // Gate open also uses overlap but handled separately when x > gate.x in step()
    }
  });

  function step(dt){
    if(world.paused) return;
    
    // Update hit effects
    world.hitEffects = world.hitEffects.filter(effect => {
      effect.x += effect.vx;
      effect.y += effect.vy;
      effect.vy += 0.2; // Gravity
      effect.life -= dt;
      
      // Fade out effect
      if (effect.life < 0.3) {
        effect.alpha = effect.life / 0.3;
      } else {
        effect.alpha = 1;
      }
      
      return effect.life > 0;
    });
    
    // Update world time for animations
    world.time = (world.time || 0) + dt;
    
    // Update player invincibility
    if(player.invincible) {
      player.invincibleTimer -= dt;
      if(player.invincibleTimer <= 0) {
        player.invincible = false;
        if(player.sprite) player.sprite.alpha = 1.0;
      } else {
        // Make player blink while invincible
        if(player.sprite) player.sprite.alpha = (Math.sin(world.time * 10) > 0) ? 0.5 : 0.8;
      }
    }

    updateMovers(dt);

    player.prevX=player.x; player.prevY=player.y;
    const left=keys['a']||keys['arrowleft'], right=keys['d']||keys['arrowright'], jumpKey=(keys[' ']||keys['space']);

    const desired = (right?1:0)-(left?1:0);
    const running = Math.sign(player.vx);
    if(player.onGround){
      if(desired!==0){ player.vx += desired*0.65; if(running!==0 && running!==desired){ player.vx += desired*0.95; } }
      else player.vx *= 0.82;
    } else { if(desired!==0) player.vx += desired*0.32; player.vx *= 0.996; }
    player.vx = clamp(player.vx, -player.base.speed, player.base.speed);
    if(right) player.facing=1; else if(left) player.facing=-1;

    player.coyote = player.onGround ? player.coyoteTime : Math.max(0, player.coyote - dt);
    player.stickTimer = Math.max(0, player.stickTimer - dt);

    const pressed = jumpKey;
    player.buffer = pressed ? player.jumpBuffer : Math.max(0, player.buffer - dt);
    if(player.buffer>0 && (player.coyote>0 || player.onGround)){
      player.vy = player.jumpVel; player.onGround=false; player.standingOn=null; player.buffer=0; player.coyote=0; sfx.jump();
    }
    if(!pressed && player.vy<0){ player.vy += player.lowJumpGravity; }
    player.vy += world.gravity;

    player.x += player.vx; player.y += player.vy;

    collideStage(player); groundSnap(player); stickyRide(player);

    const backStop = world.levelStartX + 2;
    if (player.x < backStop) { player.x = backStop; if (player.vx < 0) player.vx = 0; }

    for(const s of world.spikes){ if(player.y + player.h >= s.y && player.x + player.w > s.x && player.x < s.x + s.w){ kill(); return; } }

    for(const e of world.enemies){
      e.x += e.vx*2.0;
      if(e.x<e.pad.x || e.x+e.w>e.pad.x+e.pad.w) e.vx*=-1;
      if(aabb(player,e) && !player.invincible) { 
        // Deal damage based on enemy type
        const damage = e.damage || 20; // Default damage if not specified
        player.hp = Math.max(0, player.hp - damage);
        ui.hpBar.style.width = (player.hp / player.maxHp * 100) + '%';
        
        // Make player invincible briefly after being hit
        player.invincible = true;
        player.invincibleTimer = 1.5; // 1.5 seconds of invincibility
        
        // Visual feedback
        player.sprite.alpha = 0.5;
        
        // Check for death
        if(player.hp <= 0) {
          kill();
          return;
        }
      }
    }
    world.enemies = world.enemies.filter(e=>e.hp>0);

    world.bullets = world.bullets.filter(b=>{ b.x += b.vx*4.8; b.y += b.vy*4.8; b.life-=dt;
      return b.life>0 && b.x>world.levelStartX-120 && b.x<world.levelStartX+world.levelLength+120 && b.y>-80 && b.y<world.h+80; });
    // Check bullet collisions with enemies
    for(const b of world.bullets) { 
      for(const e of world.enemies) { 
        if(b.x>e.x && b.x<e.x+e.w && b.y>e.y && b.y<e.y+e.h) { 
          e.hp -= b.dmg; 
          e.hitTimer = 0.15; // Set hit timer for visual feedback
          
          // Create hit effect
          for(let i = 0; i < 3; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 1 + Math.random() * 2;
            world.hitEffects.push({
              x: b.x,
              y: b.y,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed,
              life: 0.5 + Math.random() * 0.5
            });
          }
          
          if(!b.pierce) b.life = -1; 
          if(e.hp <= 0) { 
            world.kills++; 
            world.score += e.score || 100;
            ui.score.textContent = world.score;
            ui.kills.textContent = world.kills; 
            
            // Death effect
            for(let i = 0; i < 10; i++) {
              const angle = Math.random() * Math.PI * 2;
              world.hitEffects.push({
                x: e.x + e.w/2,
                y: e.y + e.h/2,
                vx: Math.cos(angle) * (2 + Math.random() * 3),
                vy: Math.sin(angle) * (2 + Math.random() * 3),
                life: 0.8 + Math.random() * 0.7,
                color: e.color || '#ff7b7b'
              });
            }
          }
          
          break; // Only hit one enemy per bullet (unless it's a piercing shot)
        }
      }
    }

    // Gate check
    if(world.gate && player.x + player.w > world.gate.x){ world.paused=true; openModal('gate'); sfx.level(); }

    const targetX = Math.max(world.cam.x, player.x + player.w/2 - world.w*0.35);
    world.cam.x = clamp(world.cam.x + (targetX - world.cam.x)*0.12, world.levelStartX, world.levelStartX + world.levelLength - world.w);

    world.distance = Math.max(world.distance, Math.floor(player.x - world.levelStartX));
    ui.dist.textContent = Math.floor(world.distance/10);

    if(player.ammo===0 && !player.reloading) tryReload();
  }

  function draw(){
    ctx.fillStyle='#09121c'; ctx.fillRect(0,0,world.w,world.h);
    ctx.save(); ctx.translate(-world.cam.x, 0);

    ctx.strokeStyle='#0f1b2a'; ctx.lineWidth=1; ctx.beginPath();
    const gx0 = Math.floor(world.cam.x/40)*40, gx1 = world.cam.x+world.w;
    for(let x=gx0; x<gx1; x+=40){ ctx.moveTo(x,0); ctx.lineTo(x,world.h); }
    for(let y=0;y<world.h;y+=40){ ctx.moveTo(world.cam.x,y); ctx.lineTo(world.cam.x+world.w,y); }
    ctx.stroke();

    for(const p of world.platforms){ ctx.fillStyle=p.col; ctx.fillRect(p.x,p.y,p.w,p.h); }
    for(const m of world.movers){ ctx.fillStyle=m.col; ctx.fillRect(m.x,m.y,m.w,m.h); }

    if(world.gate){ ctx.fillStyle='#86e7ff'; ctx.fillRect(world.gate.x, world.gate.y, world.gate.w, world.gate.h); }

    for(const s of world.spikes){
      ctx.fillStyle='#183149'; ctx.fillRect(s.x, s.y, s.w, s.h);
      ctx.fillStyle='#ff6b6b';
      const count = Math.floor(s.w/16);
      for(let i=0;i<count;i++){ const bx = s.x + i*16, by = s.y;
        ctx.beginPath(); ctx.moveTo(bx,by); ctx.lineTo(bx+8,by-12); ctx.lineTo(bx+16,by); ctx.closePath(); ctx.fill();
      }
    }

    // Field crates
    const time = performance.now()/1000;
    for(const c of world.cratesArr){
      if(c.taken) continue;
      const glow = (Math.sin(time*4)+1)*0.5;
      ctx.fillStyle = `rgba(103,212,255,${0.35+glow*0.35})`;
      ctx.fillRect(c.x-6,c.y-6,c.w+12,c.h+12);
      ctx.fillStyle = '#0e2236';
      ctx.fillRect(c.x,c.y,c.w,c.h);
      ctx.strokeStyle='#67d4ff'; ctx.lineWidth=2;
      ctx.strokeRect(c.x+2,c.y+2,c.w-4,c.h-4);
    }

    // Draw hit effects first (behind everything else)
    for(const effect of world.hitEffects) {
      const size = 1 + Math.sin(effect.life * 20) * 0.5;
      ctx.globalAlpha = effect.alpha || 1;
      
      if (effect.color) {
        ctx.fillStyle = effect.color;
      } else {
        // Create gradient for default hit effect
        const gradient = ctx.createRadialGradient(
          effect.x, effect.y, 0,
          effect.x, effect.y, size * 2
        );
        gradient.addColorStop(0, 'rgba(255, 100, 100, 0.8)');
        gradient.addColorStop(1, 'rgba(255, 200, 200, 0)');
        ctx.fillStyle = gradient;
      }
      
      ctx.beginPath();
      ctx.arc(effect.x, effect.y, size * 2, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Draw enemies with hit effect
    for(const e of world.enemies) { 
      // Skip if enemy is off-screen
      if (e.x + e.w < world.cam.x || e.x > world.cam.x + world.w) continue;
      
      // Calculate screen position (accounting for camera)
      const screenX = e.x - world.cam.x;
      const screenY = e.y;
      
      // Save context for transformations
      ctx.save();
      
      // Position the enemy on screen
      ctx.translate(screenX, screenY);
      
      // Apply hit flash effect
      if(e.hitTimer > 0) {
        const flash = Math.sin(e.hitTimer * 40) * 0.5 + 0.5;
        ctx.fillStyle = `rgb(255, ${200 - flash * 100}, ${200 - flash * 100})`;
        // Slightly increase size when hit
        const scale = 1 + (1 - e.hitTimer / 0.15) * 0.1;
        ctx.translate(e.w/2, e.h/2);
        ctx.scale(scale, scale);
        ctx.translate(-e.w/2, -e.h/2);
      } else {
        ctx.fillStyle = e.color || '#ff7b7b';
      }
      
      // Draw enemy body
      ctx.fillRect(0, 0, e.w, e.h);
      
      // Enemy-specific decorations
      const type = e.type || 'WALKER'; // Default to WALKER if type not set
      switch(type) {
        case 'TANK':
          // Tank treads
          ctx.fillStyle = '#444';
          ctx.fillRect(0, 0, e.w, 4);
          ctx.fillRect(0, e.h-4, e.w, 4);
          break;
          
        case 'SHOOTER': {
          // Eye/visor
          const shooterEyeX = e.vx > 0 ? e.w - 6 : 2;
          ctx.fillStyle = '#222';
          ctx.fillRect(shooterEyeX, e.h/2 - 2, 4, 4);
          break;
        }
          
        case 'JUMPER': {
          // Legs
          ctx.fillStyle = '#d95';
          const legY = Math.sin(Date.now() * 0.01) * 2;
          ctx.fillRect(4, e.h - 4, 4, 4 + legY);
          ctx.fillRect(e.w - 8, e.h - 4, 4, 4 - legY);
          break;
        }
          
        case 'WALKER':
        default: {
          // Default walker appearance
          ctx.fillStyle = '#333';
          // Legs
          const legOffset = Math.sin(Date.now() * 0.01) * 2;
          ctx.fillRect(2, e.h - 4, 4, 4 + legOffset);
          ctx.fillRect(e.w - 6, e.h - 4, 4, 4 - legOffset);
          // Eyes
          const walkerEyeX = e.vx > 0 ? e.w - 8 : 2;
          ctx.fillStyle = '#222';
          ctx.fillRect(walkerEyeX, 6, 4, 4);
          break;
        }
      }
      
      ctx.restore();
      
      // Draw health bar for all enemies
      const maxHp = e.maxHp || 40; // Default max HP if not set
      const hp = e.hp || maxHp;     // Default to max HP if not set
      
      if(hp < maxHp) {
        const healthPercent = hp / maxHp;
        const barWidth = e.w + 10;
        const barHeight = 4;
        const barX = screenX - 5;
        const barY = screenY - 8;
        
        // Background
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(barX, barY, barWidth, barHeight);
        
        // Health bar
        ctx.fillStyle = healthPercent > 0.6 ? '#55efc4' : 
                        healthPercent > 0.3 ? '#ffd166' : '#ff6b6b';
        ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
        
        // Border
        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
        ctx.lineWidth = 1;
        ctx.strokeRect(barX, barY, barWidth, barHeight);
      }
    }
    
    // Reset global alpha
    ctx.globalAlpha = 1;

    const cx = player.x+player.w/2, cy = player.y+player.h/2;
    const ang = Math.atan2(mouse.y-(cy), mouse.x-(cx - world.cam.x));
    const len = 42;
    const ax = cx + Math.cos(ang)*len, ay = cy + Math.sin(ang)*len;
    ctx.strokeStyle='rgba(134,231,255,0.85)'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(ax,ay); ctx.stroke();
    ctx.beginPath(); const aw=5, left = ang + Math.PI*0.9, right = ang - Math.PI*0.9;
    ctx.moveTo(ax,ay); ctx.lineTo(ax + Math.cos(left)*aw, ay + Math.sin(left)*aw); ctx.lineTo(ax + Math.cos(right)*aw, ay + Math.sin(right)*aw);
    ctx.closePath(); ctx.fillStyle='rgba(134,231,255,0.85)'; ctx.fill();

    if(sprite.dirty) rebuildSprite();
    ctx.drawImage(sprite.canvas, Math.round(player.x+player.w/2-32), Math.round(player.y+player.h/2-36));

    for(const b of world.bullets){ ctx.beginPath(); ctx.fillStyle='#b9f3ff'; ctx.arc(b.x,b.y,3.5,0,Math.PI*2); ctx.fill(); }

    // Hint when overlapping a crate
    const pbox = {x:player.x, y:player.y, w:player.w, h:player.h};
    const near = world.cratesArr.find(c=>!c.taken && aabb(pbox,{x:c.x-6,y:c.y-2,w:c.w+12,h:c.h+10}));
    if(near){
      ctx.fillStyle='rgba(10,30,46,0.85)';
      ctx.fillRect(player.x-36, player.y-22, 112, 18);
      ctx.strokeStyle='#1d3b57'; ctx.strokeRect(player.x-36, player.y-22, 112, 18);
      ctx.fillStyle='#cde9ff'; ctx.font='12px ui-monospace,monospace';
      ctx.fillText('Press E to open', player.x-28, player.y-9);
    }

    ctx.restore();
  }

  function nextLevel(){
    world.level++; ui.lvl.textContent = world.level;
    world.levelStartX += world.levelLength;
    world.distance = 0;
    buildLevel();
    player.x = world.levelStartX + 40; player.y = 500 - 34; player.vx=0; player.vy=0;
    world.cam.x = world.levelStartX;
  }

  function hardRestart(){
    document.getElementById('over').style.display='none';
    world.paused=false;
    world.level=1; ui.lvl.textContent=1;
    world.lives=5; ui.lives.textContent=5;
    world.levelStartX = 0; world.distance=0; world.cratesOpened=0; world.score=0; world.kills=0;
    player.x=40; player.y=420; player.vx=0; player.vy=0; player.ammo=player.mag; player.reloading=false; document.getElementById('reloadChip').style.display='none'; document.getElementById('ammo').textContent = player.ammo+'/'+player.mag;
    buildLevel();
    world.cam.x = 0;
  }

  // Menu functions
  function showScreen(id) {
    // Hide all screens
    document.querySelectorAll('.screen').forEach(screen => {
      screen.classList.add('hidden');
    });
    
    // Show the requested screen
    const screen = document.getElementById(id);
    if (screen) {
      screen.classList.remove('hidden');
    }
    
    // Special handling for game screen
    if (id === 'wrap') {
      document.getElementById('wrap').classList.remove('hidden');
      document.getElementById('game').style.display = 'block';
      world.paused = false;
      if (world.firstRun) {
        hardRestart();
        world.firstRun = false;
      }
    } else {
      document.getElementById('wrap').classList.add('hidden');
      world.paused = true;
    }
  }
  
  // Menu event listeners
  document.getElementById('btn-start').addEventListener('click', () => {
    showScreen('wrap');
  });
  
  document.getElementById('btn-how-to-play').addEventListener('click', () => {
    showScreen('how-to-play');
  });
  
  document.getElementById('btn-credits').addEventListener('click', () => {
    showScreen('credits');
  });
  
  document.getElementById('back-from-how-to-play').addEventListener('click', () => {
    showScreen('main-menu');
  });
  
  document.getElementById('back-from-credits').addEventListener('click', () => {
    showScreen('main-menu');
  });
  
  // Game loop with error handling and performance optimizations
  let last = performance.now();
  let frameCount = 0;
  let lastFpsUpdate = 0;
  let fps = 0;
  
  function loop(t) {
    try {
      // Calculate delta time with upper bound to prevent physics issues
      let dt = Math.min(0.1, (t - last) / 1000);
      last = t;
      
      // Update FPS counter
      frameCount++;
      if (t - lastFpsUpdate > 1000) {
        fps = Math.round((frameCount * 1000) / (t - lastFpsUpdate));
        frameCount = 0;
        lastFpsUpdate = t;
        // Uncomment to log FPS (helpful for debugging)
        // console.log('FPS:', fps);
      }
      
      // Only update game logic if not paused
      if (!world.paused) {
        // Split updates into smaller chunks for stability
        const maxStep = 0.016; // ~60 FPS
        let steps = Math.ceil(dt / maxStep);
        steps = Math.min(5, Math.max(1, steps)); // Limit to prevent freezing
        
        for (let i = 0; i < steps; i++) {
          const stepDt = dt / steps;
          step(stepDt);
          fire(stepDt);
        }
        
        draw();
      }
    } catch (error) {
      console.error('Game loop error:', error);
      // Try to recover by restarting the game
      try {
        world.paused = true;
        alert('An error occurred. The game will try to recover.');
        hardRestart();
      } catch (recoveryError) {
        console.error('Recovery failed:', recoveryError);
        // If we can't recover, at least keep the game running
        world.paused = true;
      }
    } finally {
      // Always request the next frame, even if there was an error
      requestAnimationFrame(loop);
    }
  }
  //
  // Initialize with error handling
  try {
    world.firstRun = true;
    world.paused = true;
    
    // Add a small delay before starting the game loop
    setTimeout(() => {
      try {
        showScreen('main-menu');
        // Start the game loop with a small delay to ensure everything is loaded
        setTimeout(() => requestAnimationFrame(loop), 100);
      } catch (error) {
        console.error('Initialization error:', error);
        alert('Failed to initialize the game. Please refresh the page.');
      }
    }, 100);
  } catch (error) {
    console.error('Fatal initialization error: Please refresh the page', error);
    alert('A fatal error occurred during initialization. Please refresh the page.');
  }
})();
</script>
</body>
</html>
